

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Real Time Dashboards &mdash; Citus 5.2.1 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="top" title="Citus 5.2.1 documentation" href="../index.html"/>
        <link rel="next" title="Cluster Management" href="../admin_guide/cluster_management.html"/>
        <link rel="prev" title="Support and Billing" href="../cloud/support.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>
  <script>
   window.intercomSettings = {
     app_id: "jfost7ih",
   };
  </script>
  <script>(function(){var w=window;var ic=w.Intercom;if(typeof ic==="function"){ic('reattach_activator');ic('update',intercomSettings);}else{var d=document;var i=function(){i.c(arguments)};i.q=[];i.c=function(args){i.q.push(args)};w.Intercom=i;function l(){var s=d.createElement('script');s.type='text/javascript';s.async=true;s.src='https://widget.intercom.io/widget/jfost7ih';var x=d.getElementsByTagName('script')[0];x.parentNode.insertBefore(s,x);}if(w.attachEvent){w.attachEvent('onload',l);}else{w.addEventListener('load',l,false);}}})()</script>
</head>

<body class="wy-body-for-nav" role="document">
  <div class="header">
  <div class="section-wrap"> 
              <div class="utility-nav">
              </div>
                      <a href="https://www.citusdata.com" title="Citus Data" rel="home" class="logo">
            <img src="../_static/images/citus-logo.png" alt="Citus Data">
          </a>
              <div class="clear"></div>
  </div>
  </div>
  <div class="nav-wrap menu">
    <div class="section-wrap">
      <ul>
        <li><a href="https://www.citusdata.com/product/citus">Product</a></li>
        <li><a href="https://www.citusdata.com/solutions/applications">Solutions</a></li>
        <li><a href="https://www.citusdata.com/blog">Blog</a></li>
        <li><a href="#">Documentation</a></li>
      </ul>
    </div>
  </div>

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Citus
          

          
          </a>

          
            
            
              <div class="version">
                5.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">About Citus</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../aboutcitus/what_is_citus.html">What is Citus?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../aboutcitus/introduction_to_citus.html">Architecture</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/tut-hash-distribution.html">Hash-Distributed Data</a></li>
</ul>
<p class="caption"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation/requirements.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation/development.html">Single-Machine Cluster</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation/production.html">Multi-Machine Cluster</a></li>
</ul>
<p class="caption"><span class="caption-text">Distributed Tables</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dist_tables/concepts.html">Picking a Distribution Column</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dist_tables/ddl.html">Creating Distributed Tables (DDL)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dist_tables/dml.html">Ingesting, Modifying Data (DML)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dist_tables/querying.html">Querying Distributed Tables (SQL)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dist_tables/extensions.html">PostgreSQL extensions</a></li>
</ul>
<p class="caption"><span class="caption-text">Performance</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../performance/query_processing.html">Citus Query Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../performance/scaling_data_ingestion.html">Scaling Out Data Ingestion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../performance/performance_tuning.html">Query Performance Tuning</a></li>
</ul>
<p class="caption"><span class="caption-text">Cloud</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../cloud/index.html">Citus Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cloud/features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cloud/logging.html">Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cloud/support.html">Support and Billing</a></li>
</ul>
<p class="caption"><span class="caption-text">Technical Solutions</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Real Time Dashboards</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#running-it-yourself">Running It Yourself</a></li>
<li class="toctree-l2"><a class="reference internal" href="#data-model">Data Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="#rollups">Rollups</a></li>
<li class="toctree-l2"><a class="reference internal" href="#expiring-old-data">Expiring Old Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="#approximate-distinct-counts">Approximate Distinct Counts</a></li>
<li class="toctree-l2"><a class="reference internal" href="#unstructured-data-with-jsonb">Unstructured Data with JSONB</a></li>
<li class="toctree-l2"><a class="reference internal" href="#resources">Resources</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Administration</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin_guide/cluster_management.html">Cluster Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin_guide/upgrading_citus.html">Upgrading Citus</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin_guide/transitioning_from_postgresql_to_citus.html">Transitioning From PostgreSQL to Citus</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../reference/citus_sql_reference.html">Citus SQL Language Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/sql_workarounds.html">SQL Workarounds</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/user_defined_functions.html">User Defined Functions Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/metadata_tables.html">Metadata Tables Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/configuration.html">Configuration Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/append.html">Append Distribution</a></li>
</ul>
<p class="caption"><span class="caption-text">FAQ</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../faq/faq.html">Frequently Asked Questions</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <a href="../index.html">Citus</a>
      <ul>
        <li><a href="/product/citus">Product</a></li>
        <li><a href="/solutions/applications">Solutions</a></li>
        <li><a href="/blog">Blog</a></li>
      </ul>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
    <li>Real Time Dashboards</li>
    <li class="wy-breadcrumbs-aside">
      
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="real-time-dashboards">
<span id="introduction"></span><h1>Real Time Dashboards<a class="headerlink" href="#real-time-dashboards" title="Permalink to this headline">¶</a></h1>
<p>Citus provides real-time queries over large datasets. One workload we commonly see at
Citus involves powering real-time dashboards of event data.</p>
<p>For example, you could be a cloud services provider helping other businesses monitor their
HTTP traffic. Every time one of your clients receives an HTTP request your service
receives a log record. You want to ingest all those records and create an HTTP analytics
dashboard which gives your clients insights such as the number HTTP errors their sites
served. It&#8217;s important that this data shows up with as little latency as possible so your
clients can fix problems with their sites. It&#8217;s also important for the dashboard to show
graphs of historical trends.</p>
<p>Alternatively, maybe you&#8217;re building an advertising network and want to show clients
clickthrough rates on their campaigns. In this example latency is also critical, raw data
volume is also high, and both historical and live data are important.</p>
<p>In this technical solution we&#8217;ll demonstrate how to build part of the first example,
but this architecture would work equally well for the second and many other use-cases.</p>
<div class="section" id="running-it-yourself">
<h2>Running It Yourself<a class="headerlink" href="#running-it-yourself" title="Permalink to this headline">¶</a></h2>
<p>There will be code snippets in this tutorial but they don&#8217;t specify a complete system.
There&#8217;s <a class="reference external" href="https://github.com/citusdata/realtime-dashboards-resources">a github repo</a> with
all the details in one place. If you&#8217;ve followed our installation instructions for running
Citus on either a single or multiple machines you&#8217;re ready to try it out.</p>
</div>
<div class="section" id="data-model">
<h2>Data Model<a class="headerlink" href="#data-model" title="Permalink to this headline">¶</a></h2>
<p>The data we&#8217;re dealing with is an immutable stream of log data. We&#8217;ll insert directly into
Citus but it&#8217;s also common for this data to first be routed through something like Kafka.
Doing so has the usual advantages, and makes it easier to pre-aggregate the data once data
volumes become unmanageably high.</p>
<p>We&#8217;ll use a simple schema for ingesting HTTP event data. This schema serves as an example
to demonstrate the overall architecture; a real system might use additional columns.</p>
<div class="highlight-sql"><div class="highlight"><pre><span></span><span class="c1">-- this is run on the master</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">http_request</span> <span class="p">(</span>
  <span class="n">site_id</span> <span class="nb">INT</span><span class="p">,</span>
  <span class="n">ingest_time</span> <span class="n">TIMESTAMPTZ</span> <span class="k">DEFAULT</span> <span class="n">now</span><span class="p">(),</span>

  <span class="n">url</span> <span class="nb">TEXT</span><span class="p">,</span>
  <span class="n">request_country</span> <span class="nb">TEXT</span><span class="p">,</span>
  <span class="n">ip_address</span> <span class="nb">TEXT</span><span class="p">,</span>

  <span class="n">status_code</span> <span class="nb">INT</span><span class="p">,</span>
  <span class="n">response_time_msec</span> <span class="nb">INT</span>
<span class="p">);</span>
<span class="k">SELECT</span> <span class="n">master_create_distributed_table</span><span class="p">(</span><span class="s1">&#39;http_request&#39;</span><span class="p">,</span> <span class="s1">&#39;site_id&#39;</span><span class="p">,</span> <span class="s1">&#39;hash&#39;</span><span class="p">);</span>
<span class="k">SELECT</span> <span class="n">master_create_worker_shards</span><span class="p">(</span><span class="s1">&#39;http_request&#39;</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>When we call <a class="reference internal" href="../reference/user_defined_functions.html#id1"><span class="std std-ref">master_create_distributed_table</span></a>
we ask Citus to hash-distribute <code class="docutils literal"><span class="pre">http_request</span></code> using the <code class="docutils literal"><span class="pre">site_id</span></code> column. That means
all the data for a particular site will live in the same shard.</p>
<p>When we call <a class="reference internal" href="../reference/user_defined_functions.html#id2"><span class="std std-ref">master_create_worker_shards</span></a> we tell
Citus to create 16 shards and 2 replicas of each shard (for a total of 32 shard replicas).
We recommend <a class="reference internal" href="../faq/faq.html#faq-choose-shard-count"><span class="std std-ref">using 2-4x as many shards</span></a> as CPU cores in
your cluster. Using this many shards lets you rebalance data across your cluster after
adding new worker nodes.</p>
<p>Using a replication factor of 2 means every shard is held on multiple workers. When a
worker fails the master will prevent downtime by serving queries for that worker&#8217;s shards
using the other replicas.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In Citus Cloud you must use a replication factor of 1 (instead of the 2 used here). As
Citus Cloud uses <a class="reference external" href="https://www.postgresql.org/docs/current/static/warm-standby.html">streaming replication</a> to achieve high
availability maintaining shard replicas would be redundant.</p>
</div>
<p>With this, the system is ready to accept data and serve queries! We&#8217;ve provided <a class="reference external" href="https://github.com/citusdata/realtime-dashboards-resources/blob/master/ingest_example_data.sql">a data
ingest script</a>
you can run to generate example data. Once you&#8217;ve ingested data, you can run dashboard
queries such as:</p>
<div class="highlight-sql"><div class="highlight"><pre><span></span><span class="k">SELECT</span>
  <span class="n">date_trunc</span><span class="p">(</span><span class="s1">&#39;minute&#39;</span><span class="p">,</span> <span class="n">ingest_time</span><span class="p">)</span> <span class="k">as</span> <span class="k">minute</span><span class="p">,</span>
  <span class="k">COUNT</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">AS</span> <span class="n">request_count</span><span class="p">,</span>
  <span class="k">SUM</span><span class="p">(</span><span class="k">CASE</span> <span class="k">WHEN</span> <span class="p">(</span><span class="n">status_code</span> <span class="k">between</span> <span class="mi">200</span> <span class="k">and</span> <span class="mi">299</span><span class="p">)</span> <span class="k">THEN</span> <span class="mi">1</span> <span class="k">ELSE</span> <span class="mi">0</span> <span class="k">END</span><span class="p">)</span> <span class="k">as</span> <span class="n">success_count</span><span class="p">,</span>
  <span class="k">SUM</span><span class="p">(</span><span class="k">CASE</span> <span class="k">WHEN</span> <span class="p">(</span><span class="n">status_code</span> <span class="k">between</span> <span class="mi">200</span> <span class="k">and</span> <span class="mi">299</span><span class="p">)</span> <span class="k">THEN</span> <span class="mi">0</span> <span class="k">ELSE</span> <span class="mi">1</span> <span class="k">END</span><span class="p">)</span> <span class="k">as</span> <span class="n">error_count</span><span class="p">,</span>
  <span class="k">SUM</span><span class="p">(</span><span class="n">response_time_msec</span><span class="p">)</span> <span class="o">/</span> <span class="k">COUNT</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">AS</span> <span class="n">average_response_time_msec</span>
<span class="k">FROM</span> <span class="n">http_request</span>
<span class="k">WHERE</span> <span class="n">site_id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">AND</span> <span class="n">date_trunc</span><span class="p">(</span><span class="s1">&#39;minute&#39;</span><span class="p">,</span> <span class="n">ingest_time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="nb">interval</span> <span class="s1">&#39;5 minutes&#39;</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="k">minute</span><span class="p">;</span>
</pre></div>
</div>
<p>The setup described above works, but has two drawbacks:</p>
<ul class="simple">
<li>Your HTTP analytics dashboard must go over each row every time it needs to generate a
graph. For example, if your clients are interested in trends over the past year, your
queries will aggregate every row for the past year from scratch.</li>
<li>Your storage costs will grow proportionally with the ingest rate and the length of the
queryable history. In practice, you may want to keep raw events for a shorter period of
time (one month) and look at historical graphs over a longer time period (years).</li>
</ul>
</div>
<div class="section" id="rollups">
<h2>Rollups<a class="headerlink" href="#rollups" title="Permalink to this headline">¶</a></h2>
<p>You can overcome both drawbacks by rolling up the raw data into a pre-aggregated form.
Here, we&#8217;ll aggregate the raw data into a table which stores summaries of 1-minute
intervals. In a production system, you would probably also want something like 1-hour and
1-day intervals, these each correspond to zoom-levels in the dashboard. When the user
wants request times for the last month the dashboard can simply read and chart the values
for each of the last 30 days.</p>
<div class="highlight-sql"><div class="highlight"><pre><span></span><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">http_request_1min</span> <span class="p">(</span>
      <span class="n">site_id</span> <span class="nb">INT</span><span class="p">,</span>
      <span class="n">ingest_time</span> <span class="n">TIMESTAMPTZ</span><span class="p">,</span> <span class="c1">-- which minute this row represents</span>

      <span class="n">error_count</span> <span class="nb">INT</span><span class="p">,</span>
      <span class="n">success_count</span> <span class="nb">INT</span><span class="p">,</span>
      <span class="n">request_count</span> <span class="nb">INT</span><span class="p">,</span>
      <span class="n">average_response_time_msec</span> <span class="nb">INT</span><span class="p">,</span>
      <span class="k">CHECK</span> <span class="p">(</span><span class="n">request_count</span> <span class="o">=</span> <span class="n">error_count</span> <span class="o">+</span> <span class="n">success_count</span><span class="p">),</span>
      <span class="k">CHECK</span> <span class="p">(</span><span class="n">ingest_time</span> <span class="o">=</span> <span class="n">date_trunc</span><span class="p">(</span><span class="s1">&#39;minute&#39;</span><span class="p">,</span> <span class="n">ingest_time</span><span class="p">))</span>
<span class="p">);</span>
<span class="k">SELECT</span> <span class="n">master_create_distributed_table</span><span class="p">(</span><span class="s1">&#39;http_request_1min&#39;</span><span class="p">,</span> <span class="s1">&#39;site_id&#39;</span><span class="p">,</span> <span class="s1">&#39;hash&#39;</span><span class="p">);</span>
<span class="k">SELECT</span> <span class="n">master_create_worker_shards</span><span class="p">(</span><span class="s1">&#39;http_request_1min&#39;</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

<span class="c1">-- indexes aren&#39;t automatically created by Citus</span>
<span class="c1">-- this will create the index on all shards</span>
<span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">http_request_1min_idx</span> <span class="k">ON</span> <span class="n">http_request_1min</span> <span class="p">(</span><span class="n">site_id</span><span class="p">,</span> <span class="n">ingest_time</span><span class="p">);</span>
</pre></div>
</div>
<p>This looks a lot like the previous code block. Most importantly: It also shards on
<code class="docutils literal"><span class="pre">site_id</span></code> and it also uses 16 shards with 2 replicas of each. Because all three of
those match, there&#8217;s a 1-to-1 correspondence between <code class="docutils literal"><span class="pre">http_request</span></code> shards and
<code class="docutils literal"><span class="pre">http_request_1min</span></code> shards, and Citus will place matching shards on the same worker.
This is called colocation; it makes queries such as joins faster and our rollups possible.</p>
<img alt="colocation in citus" src="../_images/colocation.png" />
<p>In order to populate <code class="docutils literal"><span class="pre">http_request_1min</span></code> we&#8217;re going to periodically run the equivalent
of an INSERT INTO SELECT. Citus <a class="reference external" href="https://github.com/citusdata/citus/issues/508">doesn&#8217;t yet support</a> INSERT INTO SELECT on distributed
tables, so instead we&#8217;ll run a function on all the workers which runs INSERT INTO SELECT
on every matching pair of shards. This is possible because the tables are colocated.</p>
<div class="highlight-plpgsql"><div class="highlight"><pre><span></span><span class="c1">-- this function is created on the workers</span>
<span class="k">CREATE</span> <span class="k">FUNCTION</span> <span class="n">rollup_1min</span><span class="p">(</span><span class="n">p_source_shard</span> <span class="nb">text</span><span class="p">,</span> <span class="n">p_dest_shard</span> <span class="nb">text</span><span class="p">)</span> <span class="k">RETURNS</span> <span class="nb">void</span>
<span class="k">AS</span> <span class="s">$$</span>
<span class="k">BEGIN</span>
  <span class="c1">-- the dest shard will have a name like: http_request_1min_204566, where 204566 is the</span>
  <span class="c1">-- shard id. We lock using that id, to make sure multiple instances of this function</span>
  <span class="c1">-- never simultaneously write to the same shard.</span>
  <span class="k">IF</span> <span class="n">pg_try_advisory_xact_lock</span><span class="p">(</span><span class="mf">29999</span><span class="p">,</span> <span class="n">split_part</span><span class="p">(</span><span class="n">p_dest_shard</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="mf">4</span><span class="p">)</span><span class="o">::</span><span class="nb">int</span><span class="p">)</span> <span class="o">=</span> <span class="k">false</span> <span class="k">THEN</span>
    <span class="c1">-- N.B. make sure the int constant (29999) you use here is unique within your system</span>
    <span class="k">RETURN</span><span class="p">;</span>
  <span class="k">END</span> <span class="k">IF</span><span class="p">;</span>

  <span class="k">EXECUTE</span> <span class="n">format</span><span class="p">(</span><span class="s">$insert$</span>
<span class="s">    INSERT INTO %2$I (</span>
<span class="s">      site_id, ingest_time, request_count,</span>
<span class="s">      success_count, error_count, average_response_time_msec</span>
<span class="s">    ) SELECT</span>
<span class="s">      site_id,</span>
<span class="s">      date_trunc(&#39;minute&#39;, ingest_time) as minute,</span>
<span class="s">      COUNT(1) as request_count,</span>
<span class="s">      SUM(CASE WHEN (status_code between 200 and 299) THEN 1 ELSE 0 END) as success_count,</span>
<span class="s">      SUM(CASE WHEN (status_code between 200 and 299) THEN 0 ELSE 1 END) as error_count,</span>
<span class="s">      SUM(response_time_msec) / COUNT(1) AS average_response_time_msec</span>
<span class="s">    FROM %1$I</span>
<span class="s">    WHERE</span>
<span class="s">      date_trunc(&#39;minute&#39;, ingest_time)</span>
<span class="s">        &gt; (SELECT COALESCE(max(ingest_time), timestamp &#39;10-10-1901&#39;) FROM %2$I)</span>
<span class="s">      AND date_trunc(&#39;minute&#39;, ingest_time) &lt; date_trunc(&#39;minute&#39;, now())</span>
<span class="s">    GROUP BY site_id, minute</span>
<span class="s">    ORDER BY minute ASC;</span>
<span class="s">  $insert$</span><span class="p">,</span> <span class="n">p_source_shard</span><span class="p">,</span> <span class="n">p_dest_shard</span><span class="p">);</span>
<span class="k">END</span><span class="p">;</span>
<span class="s">$$</span> <span class="k">LANGUAGE</span> <span class="s1">&#39;plpgsql&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>Inside this function you can see the dashboard query from earlier. It&#8217;s been wrapped in
some machinery which writes the results into <code class="docutils literal"><span class="pre">http_request_1min</span></code> and allows passing in
the name of the shards to read and write from. It also takes out an advisory lock, to
ensure there aren&#8217;t any concurrency bugs where the same rows are written multiple times.</p>
<p>The machinery above which accepts the names of the shards to read and write is necessary
because only the master has the metadata required to know what the shard pairs are. It has
its own function to figure that out:</p>
<div class="highlight-plpgsql"><div class="highlight"><pre><span></span><span class="c1">-- this function is created on the master</span>
<span class="k">CREATE</span> <span class="k">FUNCTION</span> <span class="n">colocated_shard_placements</span><span class="p">(</span><span class="n">left_table</span> <span class="n">REGCLASS</span><span class="p">,</span> <span class="n">right_table</span> <span class="n">REGCLASS</span><span class="p">)</span>
<span class="k">RETURNS</span> <span class="k">TABLE</span> <span class="p">(</span><span class="n">left_shard</span> <span class="nb">TEXT</span><span class="p">,</span> <span class="n">right_shard</span> <span class="nb">TEXT</span><span class="p">,</span> <span class="n">nodename</span> <span class="nb">TEXT</span><span class="p">,</span> <span class="n">nodeport</span> <span class="nb">BIGINT</span><span class="p">)</span> <span class="k">AS</span> <span class="s">$$</span>
  <span class="k">SELECT</span>
    <span class="n">a</span><span class="mf">.</span><span class="n">logicalrelid</span><span class="o">::</span><span class="n">regclass</span><span class="o">||</span><span class="s1">&#39;_&#39;</span><span class="o">||</span><span class="n">a</span><span class="mf">.</span><span class="n">shardid</span><span class="p">,</span>
    <span class="n">b</span><span class="mf">.</span><span class="n">logicalrelid</span><span class="o">::</span><span class="n">regclass</span><span class="o">||</span><span class="s1">&#39;_&#39;</span><span class="o">||</span><span class="n">b</span><span class="mf">.</span><span class="n">shardid</span><span class="p">,</span>
    <span class="n">nodename</span><span class="p">,</span> <span class="n">nodeport</span>
  <span class="k">FROM</span> <span class="n">pg_dist_shard</span> <span class="n">a</span>
  <span class="k">JOIN</span> <span class="n">pg_dist_shard</span> <span class="n">b</span> <span class="k">USING</span> <span class="p">(</span><span class="n">shardminvalue</span><span class="p">)</span>
  <span class="k">JOIN</span> <span class="n">pg_dist_shard_placement</span> <span class="n">p</span> <span class="k">ON</span> <span class="p">(</span><span class="n">a</span><span class="mf">.</span><span class="n">shardid</span> <span class="o">=</span> <span class="n">p</span><span class="mf">.</span><span class="n">shardid</span><span class="p">)</span>
  <span class="k">WHERE</span> <span class="n">a</span><span class="mf">.</span><span class="n">logicalrelid</span> <span class="o">=</span> <span class="n">left_table</span> <span class="k">AND</span> <span class="n">b</span><span class="mf">.</span><span class="n">logicalrelid</span> <span class="o">=</span> <span class="n">right_table</span><span class="p">;</span>
<span class="s">$$</span> <span class="k">LANGUAGE</span> <span class="s1">&#39;sql&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>Using that metadata, every minute it runs a script which calls <code class="docutils literal"><span class="pre">rollup_1min</span></code> once for
each pair of shards:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env bash</span>

<span class="nv">QUERY</span><span class="o">=</span><span class="k">$(</span>cat <span class="s">&lt;&lt;END</span>
<span class="s">  SELECT * FROM colocated_shard_placements(</span>
<span class="s">    &#39;http_request&#39;::regclass, &#39;http_request_1min&#39;::regclass</span>
<span class="s">  );</span>
<span class="s">END</span>
<span class="k">)</span>

<span class="nv">COMMAND</span><span class="o">=</span><span class="s2">&quot;psql -h \$2 -p \$3 -c \&quot;SELECT rollup_1min(&#39;\$0&#39;, &#39;\$1&#39;)\&quot;&quot;</span>

psql -tA -F<span class="s2">&quot; &quot;</span> -c <span class="s2">&quot;</span><span class="nv">$QUERY</span><span class="s2">&quot;</span> <span class="p">|</span> xargs -P32 -n4 sh -c <span class="s2">&quot;</span><span class="nv">$COMMAND</span><span class="s2">&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>There are many ways to make sure the function is called periodically and no answer that
works well for every system. If you&#8217;re able to run cron on the same machine as the
master, and assuming you named the above script <code class="docutils literal"><span class="pre">run_rollups.sh</span></code>, you can do something
as simple as this:</p>
<div class="last highlight-bash"><div class="highlight"><pre><span></span>* * * * * /some/path/run_rollups.sh
</pre></div>
</div>
</div>
<p>The dashboard query from earlier is now a lot nicer:</p>
<div class="highlight-sql"><div class="highlight"><pre><span></span><span class="k">SELECT</span>
  <span class="n">request_count</span><span class="p">,</span> <span class="n">success_count</span><span class="p">,</span> <span class="n">error_count</span><span class="p">,</span> <span class="n">average_response_time_msec</span>
<span class="k">FROM</span> <span class="n">http_request_1min</span>
<span class="k">WHERE</span> <span class="n">site_id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">AND</span> <span class="n">date_trunc</span><span class="p">(</span><span class="s1">&#39;minute&#39;</span><span class="p">,</span> <span class="n">ingest_time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">date_trunc</span><span class="p">(</span><span class="s1">&#39;minute&#39;</span><span class="p">,</span> <span class="n">now</span><span class="p">())</span> <span class="o">-</span> <span class="nb">interval</span> <span class="s1">&#39;5 minutes&#39;</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="expiring-old-data">
<h2>Expiring Old Data<a class="headerlink" href="#expiring-old-data" title="Permalink to this headline">¶</a></h2>
<p>The rollups make queries faster, but we still need to expire old data to avoid unbounded
storage costs. Once you decide how long you&#8217;d like to keep data for each granularity, you
could easily write a function to expire old data. In the following example, we decided to
keep raw data for one day and 1-minute aggregations for one month.</p>
<div class="highlight-plpgsql"><div class="highlight"><pre><span></span><span class="c1">-- another function for the master</span>
<span class="k">CREATE</span> <span class="k">FUNCTION</span> <span class="n">expire_old_request_data</span><span class="p">()</span> <span class="k">RETURNS</span> <span class="nb">void</span>
<span class="k">AS</span> <span class="s">$$</span>
  <span class="k">SET</span> <span class="k">LOCAL</span> <span class="n">citus</span><span class="mf">.</span><span class="n">all_modification_commutative</span> <span class="k">TO</span> <span class="k">TRUE</span><span class="p">;</span>
  <span class="k">SELECT</span> <span class="n">master_modify_multiple_shards</span><span class="p">(</span>
    <span class="s1">&#39;DELETE FROM http_request WHERE ingest_time &lt; now() - interval &#39;&#39;1 day&#39;&#39;;&#39;</span><span class="p">);</span>
  <span class="k">SELECT</span> <span class="n">master_modify_multiple_shards</span><span class="p">(</span>
    <span class="s1">&#39;DELETE FROM http_request_1min WHERE ingest_time &lt; now() - interval &#39;&#39;1 month&#39;&#39;;&#39;</span><span class="p">);</span>
<span class="k">END</span><span class="p">;</span>
<span class="s">$$</span> <span class="k">LANGUAGE</span> <span class="s1">&#39;sql&#39;</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The above function should be called every minute. You could do this by adding a crontab
entry on the master node:</p>
<div class="last highlight-bash"><div class="highlight"><pre><span></span>* * * * * psql -c <span class="s2">&quot;SELECT expire_old_request_data();&quot;</span>
</pre></div>
</div>
</div>
<p>That&#8217;s the basic architecture! We provided an architecture that ingests HTTP events and
then rolls up these events into their pre-aggregated form. This way, you can both store
raw events and also power your analytical dashboards with subsecond queries.</p>
<p>The next sections extend upon the basic architecture and show you how to resolve questions
which often appear.</p>
</div>
<div class="section" id="approximate-distinct-counts">
<h2>Approximate Distinct Counts<a class="headerlink" href="#approximate-distinct-counts" title="Permalink to this headline">¶</a></h2>
<p>A common question in http analytics deals with <a class="reference internal" href="../dist_tables/querying.html#count-distinct"><span class="std std-ref">approximate distinct counts</span></a>: How many unique visitors visited your site over the last month?
Answering this question exactly requires storing the list of all previously-seen visitors
in the rollup tables, a prohibitively large amount of data. A datatype called hyperloglog,
or HLL, can answer the query approximately; it takes a surprisingly small amount of space
to tell you approximately how many unique elements are in a set you pass it. Its accuracy
can be adjusted. We&#8217;ll use ones which, using only 1280 bytes, will be able to count up to
tens of billions of unique visitors with at most 2.2% error.</p>
<p>An equivalent problem appears if you want to run a global query, such as the number of
unique ip addresses which visited any of your client&#8217;s sites over the last month. Without
HLLs this query involves shipping lists of ip addresses from the workers to the master for
it to deduplicate. That&#8217;s both a lot of network traffic and a lot of computation. By using
HLLs you can greatly improve query speed.</p>
<p>First you must install the hll extension; <a class="reference external" href="https://github.com/aggregateknowledge/postgresql-hll">the github repo</a> has instructions. Next, you have
to enable it:</p>
<div class="highlight-sql"><div class="highlight"><pre><span></span><span class="c1">-- this part must be run on all nodes</span>
<span class="k">CREATE</span> <span class="n">EXTENSION</span> <span class="n">hll</span><span class="p">;</span>

<span class="c1">-- this part runs on the master</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">http_request_1min</span> <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">distinct_ip_addresses</span> <span class="n">hll</span><span class="p">;</span>
</pre></div>
</div>
<p>When doing our rollups, we can now aggregate sessions into an hll column with queries
like this:</p>
<div class="highlight-sql"><div class="highlight"><pre><span></span><span class="k">SELECT</span>
  <span class="n">site_id</span><span class="p">,</span> <span class="n">date_trunc</span><span class="p">(</span><span class="s1">&#39;minute&#39;</span><span class="p">,</span> <span class="n">ingest_time</span><span class="p">)</span> <span class="k">as</span> <span class="k">minute</span><span class="p">,</span>
  <span class="n">hll_add_agg</span><span class="p">(</span><span class="n">hll_hash_text</span><span class="p">(</span><span class="n">ip_address</span><span class="p">))</span> <span class="k">AS</span> <span class="n">distinct_ip_addresses</span>
<span class="k">FROM</span> <span class="n">http_request</span>
<span class="k">WHERE</span> <span class="n">date_trunc</span><span class="p">(</span><span class="s1">&#39;minute&#39;</span><span class="p">,</span> <span class="n">ingest_time</span><span class="p">)</span> <span class="o">=</span> <span class="n">date_trunc</span><span class="p">(</span><span class="s1">&#39;minute&#39;</span><span class="p">,</span> <span class="n">now</span><span class="p">())</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">site_id</span><span class="p">,</span> <span class="k">minute</span><span class="p">;</span>
</pre></div>
</div>
<p>Now dashboard queries are a little more complicated, you have to read out the distinct
number of ip addresses by calling the <code class="docutils literal"><span class="pre">hll_cardinality</span></code> function:</p>
<div class="highlight-sql"><div class="highlight"><pre><span></span><span class="k">SELECT</span>
  <span class="n">request_count</span><span class="p">,</span> <span class="n">success_count</span><span class="p">,</span> <span class="n">error_count</span><span class="p">,</span> <span class="n">average_response_time_msec</span><span class="p">,</span>
  <span class="n">hll_cardinality</span><span class="p">(</span><span class="n">distinct_ip_addresses</span><span class="p">)</span> <span class="k">AS</span> <span class="n">distinct_ip_address_count</span>
<span class="k">FROM</span> <span class="n">http_request_1min</span>
<span class="k">WHERE</span> <span class="n">site_id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">AND</span> <span class="k">minute</span> <span class="o">=</span> <span class="n">date_trunc</span><span class="p">(</span><span class="s1">&#39;minute&#39;</span><span class="p">,</span> <span class="n">now</span><span class="p">());</span>
</pre></div>
</div>
<p>HLLs aren&#8217;t just faster, they let you do things you couldn&#8217;t previously. Say we did our
rollups, but instead of using HLLs we saved the exact unique counts. This works fine, but
you can&#8217;t answer queries such as &#8220;how many distinct sessions were there during this
one-week period in the past we&#8217;ve thrown away the raw data for?&#8221;.</p>
<p>With HLLs, this is easy. You&#8217;ll first need to inform Citus about the <code class="docutils literal"><span class="pre">hll_union_agg</span></code>
aggregate function and its semantics. You do this by running the following:</p>
<div class="highlight-sql"><div class="highlight"><pre><span></span><span class="c1">-- this should be run on the workers and master</span>
<span class="k">CREATE</span> <span class="k">AGGREGATE</span> <span class="k">sum</span> <span class="p">(</span><span class="n">hll</span><span class="p">)</span>
<span class="p">(</span>
  <span class="n">sfunc</span> <span class="o">=</span> <span class="n">hll_union_agg</span><span class="p">,</span>
  <span class="k">stype</span> <span class="o">=</span> <span class="n">internal</span><span class="p">,</span>
<span class="p">);</span>
</pre></div>
</div>
<p>Now, when you call SUM over a collection of HLLs, PostgreSQL will return the HLL for us.
You can then compute distinct ip counts over a time period with the following query:</p>
<div class="highlight-sql"><div class="highlight"><pre><span></span><span class="k">SELECT</span>
  <span class="n">hll_cardinality</span><span class="p">(</span><span class="k">SUM</span><span class="p">(</span><span class="n">distinct_ip_addresses</span><span class="p">))</span>
<span class="k">FROM</span> <span class="n">http_request_1min</span>
<span class="k">WHERE</span> <span class="n">ingest_time</span> <span class="k">BETWEEN</span> <span class="k">timestamp</span> <span class="s1">&#39;06-01-2016&#39;</span> <span class="k">AND</span> <span class="s1">&#39;06-28-2016&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>You can find more information on HLLs <a class="reference external" href="https://github.com/aggregateknowledge/postgresql-hll">in the project&#8217;s GitHub repository</a>.</p>
</div>
<div class="section" id="unstructured-data-with-jsonb">
<h2>Unstructured Data with JSONB<a class="headerlink" href="#unstructured-data-with-jsonb" title="Permalink to this headline">¶</a></h2>
<p>Citus works well with Postgres&#8217; built-in support for unstructured data types. To
demonstrate this, let&#8217;s keep track of the number of visitors which came from each country.
Using a semi-structure data type saves you from needing to add a column for every
individual country and ending up with rows that have hundreds of sparsely filled columns.
We have <a class="reference external" href="https://www.citusdata.com/blog/2016/07/14/choosing-nosql-hstore-json-jsonb/">a blog post</a> explaining
which format to use for your semi-structured data. The post recommends JSONB, here we&#8217;ll
demonstrate how to incorporate JSONB columns into your data model.</p>
<p>First, add the new column to our rollup table:</p>
<div class="highlight-sql"><div class="highlight"><pre><span></span><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">http_request_1min</span> <span class="k">ADD</span> <span class="k">COLUMN</span> <span class="n">country_counters</span> <span class="n">JSONB</span><span class="p">;</span>
</pre></div>
</div>
<p>Next, include it in the rollups by adding a clause like this to the rollup function:</p>
<div class="highlight-sql"><div class="highlight"><pre><span></span><span class="k">SELECT</span>
  <span class="n">site_id</span><span class="p">,</span> <span class="k">minute</span><span class="p">,</span>
  <span class="n">jsonb_object_agg</span><span class="p">(</span><span class="n">request_country</span><span class="p">,</span> <span class="n">country_count</span><span class="p">)</span>
<span class="k">FROM</span> <span class="p">(</span>
  <span class="k">SELECT</span>
    <span class="n">site_id</span><span class="p">,</span> <span class="n">date_trunc</span><span class="p">(</span><span class="s1">&#39;minute&#39;</span><span class="p">,</span> <span class="n">ingest_time</span><span class="p">)</span> <span class="k">AS</span> <span class="k">minute</span><span class="p">,</span>
    <span class="n">request_country</span><span class="p">,</span>
    <span class="k">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">AS</span> <span class="n">country_count</span>
  <span class="k">FROM</span> <span class="n">http_request</span>
  <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">site_id</span><span class="p">,</span> <span class="k">minute</span><span class="p">,</span> <span class="n">request_country</span>
<span class="p">)</span> <span class="k">AS</span> <span class="n">subquery</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">site_id</span><span class="p">,</span> <span class="k">minute</span><span class="p">;</span>
</pre></div>
</div>
<p>Now, if you want to get the number of requests which came from america in your dashboard,
your can modify the dashboard query to look like this:</p>
<div class="highlight-sql"><div class="highlight"><pre><span></span><span class="k">SELECT</span>
  <span class="n">request_count</span><span class="p">,</span> <span class="n">success_count</span><span class="p">,</span> <span class="n">error_count</span><span class="p">,</span> <span class="n">average_response_time_msec</span><span class="p">,</span>
  <span class="n">country_counters</span><span class="o">-&gt;</span><span class="s1">&#39;USA&#39;</span> <span class="k">AS</span> <span class="n">american_visitors</span>
<span class="k">FROM</span> <span class="n">http_request_1min</span>
<span class="k">WHERE</span> <span class="n">site_id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">AND</span> <span class="k">minute</span> <span class="o">=</span> <span class="n">date_trunc</span><span class="p">(</span><span class="s1">&#39;minute&#39;</span><span class="p">,</span> <span class="n">now</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="resources">
<h2>Resources<a class="headerlink" href="#resources" title="Permalink to this headline">¶</a></h2>
<p>This article shows a complete system to give you an idea of what building a non-trivial
application with Citus looks like. Again, there&#8217;s <a class="reference external" href="https://github.com/citusdata/realtime-dashboards-resources">a github repo</a> with all the scripts
mentioned here.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../admin_guide/cluster_management.html" class="btn btn-neutral float-right" title="Cluster Management" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../cloud/support.html" class="btn btn-neutral" title="Support and Billing" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Citus Data.

    </p>
  </div> 

</footer>

          <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-32858865-1', 'auto');
  ga('send', 'pageview');

</script>
<script>
/**
* Function that tracks a click on an outbound link in Analytics.
* This function takes a valid URL string as an argument, and uses that URL string
* as the event label. Setting the transport method to 'beacon' lets the hit be sent
* using 'navigator.sendBeacon' in browser that support it.
*/
var trackOutboundLink = function(url) {
   ga('send', 'event', 'outbound', 'click', url, {
     'transport': 'beacon',
     'hitCallback': function(){document.location = url;}
   });
}
</script>

        </div>
      </div>

    </section>

  </div>
  
<h3>Versions</h3>
<ul>
    <li><a href="../v5.2/tech_soln/real_time_dashboards.html">v5.2</a></li>
</ul>

  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'5.2.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>